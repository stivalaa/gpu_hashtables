/*****************************************************************************
 *
 * File:    knapsack_gpu_iit.cu
 * Author:  Alex Stivala
 * Created: April 2009
 *
 * $Id: knapsack_gpu_iit.cu 4545 2013-01-11 05:18:33Z astivala $
 *
 * This is the GPU implementation using the IIT GPU lock free hash table.
 * Ref:
 *  Prabhakar Misra and Mainak Chaudhuri. Performance Evaluation of Concurrent 
 *  Lock-free Data Structures on GPUs. In Proceedings of the 18th IEEE 
 *  International Conference on Parallel and Distributed Systems, December 2012.
 *
 *
 *
 *  Usage: knapsack_gpu_iit [-nvy] [-r threads]  < problemspec
 *          -v: Verbose output 
 *          -n: assume no name in the first line of the file
 *          -y: show instrumentatino summary line (like -t but one line summary)
 *
 * The problemspec is in the format generated by gen2.c from David Pisinger
 * (http://www.diku.dk/hjemmesider/ansatte/pisinger/codes.html):
 *
 * numitems
 *      1 profit_1 weight_1
 *      2 profit_2 weight_2  
 *       ...
 *      numitems profit_numitems weight_numitems
 * capacity 
 *
 * all profits and weights are positive integers.
 *
 * 
 * Requires CUDA 4.x and device with compute capability 2.x and higher
 * as it uses atomic CAS on 64 bits and __device__ function recursion.
 * Also printf() from device function for debug.
 * It uses the CURAND library for pseudrandom number generation.
 *
 * Preprocessor symbols:
 *
 * DEBUG          - compile in lots of debugging code.
 *
 *****************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <assert.h>
#include <sys/time.h>
#include <sys/resource.h>

//#include "bpautils.h" /* nvcc won't compile this due to some c++ crap */

#include "curand_kernel.h"


#ifdef DEBUG
#define DEBUG_PRINT(x)  printf x
#else
#define DEBUG_PRINT(x) /* nothing */
#endif


/*****************************************************************************
 *
 * global constants
 *
 *****************************************************************************/

// size of constant memory on device to store profit,weight for each item
#define MAX_KNAPSACK_ITEMS 512

// nothing to do with ITEMS in knapsack, it is max  possible hashtable insertions
#define NUM_ITEMS 1000000 /* FIXME */

#include "LockFreeHashTableValues_kernel.cu"


/*****************************************************************************
 *
 * type definitions
 *
 *****************************************************************************/

typedef unsigned long long uint64_t;
typedef unsigned int       uint32_t;
typedef unsigned short     uint16_t;
typedef unsigned char      uint8_t;




/* definition of type for an item */
typedef struct item_s
{
    unsigned int profit;
    unsigned int weight;
} item_t;


/*****************************************************************************
 *
 * device constant data
 *
 *****************************************************************************/

__constant__ item_t c_KNAPSACK_ITEMS[MAX_KNAPSACK_ITEMS];
const char *c_KNAPSACK_ITEMS_symbol = "c_KNAPSACK_ITEMS";
 

/*****************************************************************************
 *
 * static data
 *
 *****************************************************************************/

static bool printstats; /* whether to print call stats */
static bool verbose;    /* verbose output  */
static bool show_stats_summary = 0; /* -y summary instrumentation stats */


static unsigned int CAPACITY; /* total capacity for the problem */
static unsigned int NUM_KNAPSACK_ITEMS; /* number of items */
static item_t *KNAPSACK_ITEMS;         /* array of item profits and weights (0 unused)*/



/*****************************************************************************
 *
 * host static functions
 *
 *****************************************************************************/

/* 
 * Read the input from stdin in the gen2.c format:
 *
 * numitems
 *      1 profit_1 weight_1
 *      2 profit_2 weight_2  
 *       ...
 *      numitems profit_numitems weight_numitems
 * capacity 
 *
 * all profits and weights are positive integers.
 *
 * Parameters:
 *     None.
 * Return value:
 *     None.
 * Uses global data (write): 
 *      KNAPSACK_ITEMS        - allocates array, sets profit and weight for each item
 *      CAPACITY     - sets capacity for problem
 *      NUM_KNAPSACK_ITEMS   - number of items
 */
static void readdata(void)
{
  unsigned int i,inum;

  if (scanf("%d", &NUM_KNAPSACK_ITEMS) != 1)
  {
    fprintf(stderr, "ERROR reading number of items\n");
    exit(EXIT_FAILURE);
  }
  if (!(KNAPSACK_ITEMS = (item_t *)malloc((NUM_KNAPSACK_ITEMS+1) * sizeof(item_t))))
  {
    fprintf(stderr,"malloc KNAPSACK_ITEMS failed\n");
    exit(EXIT_FAILURE);
  }
  for (i = 1; i <= NUM_KNAPSACK_ITEMS; i++)
  {
    if(scanf("%d %d %d", &inum, &KNAPSACK_ITEMS[i].profit, &KNAPSACK_ITEMS[i].weight) != 3)
    {
      fprintf(stderr, "ERROR reading item %d\n", i);
      exit(EXIT_FAILURE);
    }
    if (inum != i)
    {
      fprintf(stderr, "ERROR expecting item %d got %d\n", i, inum);
      exit(EXIT_FAILURE);
    }
  }  
  if (scanf("%d", &CAPACITY) != 1)
  {
    fprintf(stderr, "ERROR reading capacity\n");
    exit(EXIT_FAILURE);
  }
}



/*****************************************************************************
 *
 * device functions
 *
 *****************************************************************************/


/*
 * oahttslf_insert_indices()
 *
 * Insert value for (i,j) into the hashtable
 *
 * Parameters:
 *    i,j - indices to build insertion key
 *    value - value to insert for the key
 *    thread_id - id (0,...n, not pthread id) of this thread
 *
 * Return value:
 *    None.
 */
__device__ void insert_indices(unsigned int i, unsigned int j,
                               unsigned int value)
{
  uint64_t key, val64;

  key = ((uint64_t)i << 32) | (j & 0xffffffff);
  val64 = (uint64_t)value;
  LL bkt = Hash(key);
  bucketList[bkt]->Add(key, val64);
}



/*
 * lookup_indices()
 *
 * Get the value for (i,j) from the hashtable
 *
 * Parameters:
 *     i,j - indices to build key for lookup
 *     pvalue - (OUTPUT) value for key, only set if TRUE returned
 * 
 * Return value:
 *     TRUE if found, FALSE otherwise
 */
__device__ bool lookup_indices(unsigned int i, unsigned int j, 
                               unsigned int *pvalue)
{
  uint64_t key,val64;
  bool found;

  key = ((uint64_t)i << 32) | (j & 0xffffffff);
  LL bkt = Hash(key);
  found =  bucketList[bkt]->Search(key, val64);
  *pvalue = ((unsigned int)val64); // avoid  branch by setting even if invalid
  return found;
}

/*
 * dp_knapsack()
 *
 *      This version is multi-threaded, sharing hashtable used to
 *      store computed values between the threads.
 *      This function is called by dp_knapsack_kernel()
 *      with identical instances running
 *      in several threads. This functino itself is recursive
 *      (never creates threads itself) and diverges as there is 
 *      a random choice as to which of the paths we take first; we use
 *      parallelism to explore the search space concurrently with
 *      diverged paths due to this choice, but still reusing computed
 *      values by the shared lock-free hashtable.
 *
 *
 *      This version uses no bounding.
 *
 *      Parameters:   i - item index
 *                    w - total weight
 *                state - CURAND state for random number generation
 *
 *     global constant memory:
 *
 *            c_KNAPSACK_ITEMS - array of profit and weight for each item
 *
 *      Return value: 
 *                    value of d.p. at (i,w)
 *
 */
__device__ unsigned int dp_knapsack(unsigned int i, unsigned int w, 
                                    curandState *state)
{
  unsigned int p,pwithout,pwith;
  int tid=blockIdx.x*blockDim.x+threadIdx.x;
  curandState localState = state[tid];

  DEBUG_PRINT(("(1) blockIdx.x = %d blockDim.x = %d threadIx = %d tid = %d\n",
               blockIdx.x, blockDim.x, threadIdx.x, tid));
  DEBUG_PRINT(("dp_knapsack_kernel tid = %d i = %u w = %u\n", tid,i,w));

  /* memoization: if value here already computed then do nothing */
  if (lookup_indices(i, w, &p))
  {
    DEBUG_PRINT(("dp_knapsack_kernel tid = %d found %d,%d p = %d",
                 tid, i, w, p));
    return p;
  }

  if (i == 0 || w == 0)
  {
    p = 0;
  }
  else if (w < c_KNAPSACK_ITEMS[i].weight)
  {
    DEBUG_PRINT(("dp_knapsack_kernel LT tid = %d w (%d) < k[%d] (%d)\n",tid,w,i,c_KNAPSACK_ITEMS[i].weight));

    p = dp_knapsack(i - 1, w, state);

    DEBUG_PRINT(("dp_knapsack_kernel LT tid = %d p = %d\n", tid, p));
  }
  else
  {
    DEBUG_PRINT(("dp_knapsack_kernel GE_start tid = %d\n", tid));

    if (curand(&localState) & 1)
    {
      pwithout = dp_knapsack(i - 1, w, state);
      pwith = dp_knapsack(i - 1, w - c_KNAPSACK_ITEMS[i].weight, state) + 
        c_KNAPSACK_ITEMS[i].profit;
    }
    else
    {
      pwith = dp_knapsack(i - 1, w - c_KNAPSACK_ITEMS[i].weight, state) +
        c_KNAPSACK_ITEMS[i].profit;
      pwithout = dp_knapsack(i - 1, w, state);
    }
    p = MAX(pwithout, pwith);

    DEBUG_PRINT(("dp_knapsack_kernel GE tid = %d p = %d\n", tid, p));
  }

  DEBUG_PRINT(("dp_knapsack_kernel end tid = %d p = %u\n", tid, p));

  state[tid] = localState;

  insert_indices(i, w, p);
  return p;
}


/*****************************************************************************
 *
 * global functions
 *
 *****************************************************************************/

/*
 * init_rng()
 *
 * Initialize CURAND pseudrandom number generator
 * See CUDA Toolkit 4.1 CURAND Guide (p.21)
 *
 * Parameters:
 *    state - CURAND state for random number generation
 *    seed  - seed for CURAND init
 *
 */
__global__ void init_rng(curandState *state, unsigned long long seed)
{
  int tid=blockIdx.x*blockDim.x+threadIdx.x;

  /* give each therad same seed, different sequence number, no offset */
  curand_init(seed, tid, 0, &state[tid]);
}
 
 

/*
 * dp_knapsack_kernel()
 *
 *    Caller interafce to the multithreaded version: just calls the actual
 *    device function
 *
 *
 *    Paramters:
 *        i - item index to start at
 *        w - total capacity to start at
 *        p - (output) score for this product set
 *    state - CURAND state for random number generation
 */
__global__ void dp_knapsack_kernel(unsigned int i, unsigned int w,
                                   unsigned int *p, curandState *state)
{
 int tid=blockIdx.x*blockDim.x+threadIdx.x;
 unsigned int profit;

  DEBUG_PRINT(("(0) blockIdx.x = %d blockDim.x = %d threadIx = %d tid = %d\n",
               blockIdx.x, blockDim.x, threadIdx.x, tid));
  // testing if recursion works at all
//  int f = tid % 10;
//  int factorial = fact(f);
//  DEBUG_PRINT(("tid = %d f = %d fact = %d\n", tid, f, factorial));
//  return;
  

  /* TODO FIXME get result from first thread to finish not thread 0 always */
  profit = dp_knapsack(i, w, state);


  __syncthreads();

  DEBUG_PRINT(("dp_knapsack_kernel tid = %d i = %u w = %u profit = %u\n", tid,i,w,profit));

  if (tid == 0)
  {
     DEBUG_PRINT(("SET profit = %d (tid = %d)\n", profit, tid));
     *p = profit;
  }
}

/*****************************************************************************
 *
 * host main
 *
 *****************************************************************************/

/*
 * print usage message and exit
 *
 */
static void usage(const char *program)
{
  fprintf(stderr, 
          "Usage: %s [-ntvy]  < problemspec\n"
          "  -n: assume no name in the first line of the file\n"
          "  -t: show statistics of operations\n"
          "  -v: Verbose output\n"
          "  -y: show instrumentatino summary line (like -t but one line summary)\n",
          program);
  
  exit(EXIT_FAILURE);
}




/*
 * main
 */
int main(int argc, char *argv[])
{
  int i = 0;
  char flags[100];
  int c;
  int otime, ttime, etime;
  unsigned int profit =0;
  unsigned int *d_profit ;
  struct rusage starttime,totaltime,runtime,endtime,opttime;
  struct timeval start_timeval,end_timeval,elapsed_timeval;
  unsigned int t;
  char name[100];
  int noname = 0;
  cudaError_t rc;
  curandState *devStates;
  unsigned int hTimer;
  size_t stacksize;


  strcpy(flags, "[NONE]");

  gettimeofday(&start_timeval, NULL);

  while ((c = getopt(argc, argv, "nvyt?")) != -1)
  {
    switch(c) {
      case 'v':
	/* verbose output */
	verbose = 1;
	break;
      case 't':
	/* show stats */
	printstats = 1;
	break;
      case 'n':
        /* no name on first line of input */
        noname = 1;
        break;
      case 'y':
        /* show statistics summaary line of insturmentation */
        show_stats_summary = 1;
        break;
      default:
        usage(argv[0]);
   	    break;
    }
    if (i < (int)sizeof(flags)-1)
      flags[i++] = c;
  }

  if (i > 0)
    flags[i] = '\0';

  /* we should have no command line parameters */
  if (optind != argc)
    usage(argv[0]);
 
	// Pick the best GPU available, or if the developer selects one at the command line
	int devID = cutilChooseCudaDevice(argc, argv);
	cudaDeviceProp deviceProp;
	cudaGetDeviceProperties(&deviceProp, devID);
	printf("> GPU Device has Compute Capabilities SM %d.%d\n\n", deviceProp.major, deviceProp.minor);
	int version = (deviceProp.major * 0x10 + deviceProp.minor);
	if (version < 0x20) {
    fprintf(stderr, "device with compute capability 2.0 or better is required\n");
    exit(1);
  }

  // We need L1 cache to store the stack (only applicable to sm_20 and higher)
  if ((rc = cudaFuncSetCacheConfig(dp_knapsack_kernel,
                                   cudaFuncCachePreferL1)) != cudaSuccess)
  {
    fprintf(stderr, "cudaFuncSetCacheConfig failed %d\n", rc);
    exit(1);
  }
  const int STACKSIZE = 65536; /* in bytes */
  if ((rc = cudaDeviceSetLimit(cudaLimitStackSize, STACKSIZE)) != cudaSuccess)
  {
    fprintf(stderr, "cudaDeviceSetLimit failed %d\n",rc);
    exit(1);
  }
  if ((rc = cudaDeviceGetLimit(&stacksize, cudaLimitStackSize)) != cudaSuccess)
  {
    fprintf(stderr, "cudaDeviceGetLimit failed %d\n",rc);
    exit(1);
  }
  fprintf(stderr, "cuda stack size = %.1f KB\n", (double)stacksize/1024);
  assert(stacksize == STACKSIZE);

  if (noname) 
    strcpy(name,"[NONE]\n");
  else
    fgets(name,sizeof(name)-1,stdin);


  getrusage(RUSAGE_SELF, &starttime);

  readdata(); /* read into the KNAPSACK_ITEMS array and set CAPACITY, NUM_KNAPSACK_ITEMS */

  if (NUM_KNAPSACK_ITEMS > MAX_KNAPSACK_ITEMS)
  {
    fprintf(stderr, 
            "num knapsack items %d exceeds %d, increase MAX_KNAPSACK_ITEMS\n",
            NUM_KNAPSACK_ITEMS, MAX_KNAPSACK_ITEMS);
    exit(1);
  }

  cutCreateTimer(&hTimer) ;
  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;

  /* copy the knapsack items to device constant memory */
  if ((rc = cudaMemcpyToSymbol(c_KNAPSACK_ITEMS_symbol, KNAPSACK_ITEMS, 
                               NUM_KNAPSACK_ITEMS*sizeof(item_t)))!= cudaSuccess)
  {
    fprintf(stderr, "cudaMemcpyTosymbol failed %d\n", rc);
  }
  
  cutStopTimer(hTimer);
  fprintf(stderr, "copy %.1f KB of knapsack data to constant memory: %f ms\n",
          (double)sizeof(NUM_KNAPSACK_ITEMS*sizeof(item_t)/1024.0,
                         cutGetTimerValue(hTimer)));

  int blocks = 1;//FIXME



  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;

  /* allocate space on device for random number generator state */
  if ((rc = cudaMalloc((void **)&devStates, 
                       blocks*NUM_THREADS*sizeof(curandState))) != cudaSuccess)
  {
    fprintf(stderr, "cudaMalloc devStates failed %d\n", rc);
    exit(1);
  }
  
  /* initialize device random number generator */
  init_rng<<<blocks, NUM_THREADS>>>(devStates, time(NULL));
  if ((rc = cudaGetLastError()) != cudaSuccess)
  {
    fprintf(stderr, "init_rng kernel error %d\n", rc);
  }
  cutilDeviceSynchronize();
  if ((rc = cudaGetLastError()) != cudaSuccess)
  {
    fprintf(stderr, "init_rng sync error %d\n", rc);
  }

  fprintf(stderr, "allocate and initialize CURAND device RNG for %d threads: %f ms\n",
          blocks*NUM_THREADS, cutGetTimerValue(hTimer));

  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;
  
  // Allocate hash table

  LinkedList* buckets[NUM_BUCKETS];
  LinkedList** Cbuckets;

  for(i=0;i<NUM_BUCKETS;i++){
#ifdef _CUTIL_H_
    CUDA_SAFE_CALL(cudaMalloc((void**)&(buckets[i]), sizeof(LinkedList)));
#else
    cudaMalloc((void**)&(buckets[i]), sizeof(LinkedList));
#endif
    LinkedList* l=new LinkedList(i);
#ifdef _CUTIL_H_
    CUDA_SAFE_CALL(cudaMemcpy(buckets[i], l, sizeof(LinkedList), cudaMemcpyHostToDevice));
#else
    cudaMemcpy(buckets[i], l, sizeof(LinkedList), cudaMemcpyHostToDevice);
#endif
  }

  cutStopTimer(hTimer) ;
  fprintf(stderr, "alloc and copy buckets in loop (%f MB) time: %f ms\n", ((double)sizeof(LinkedList)*NUM_BUCKETS)/(1024*1024), cutGetTimerValue(hTimer));

  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;

#ifdef _CUTIL_H_
  CUDA_SAFE_CALL(cudaMalloc((void**)&(Cbuckets), sizeof(LinkedList*)*NUM_BUCKETS));
#else
  cudaMalloc((void**)&(Cbuckets), sizeof(LinkedList*)*NUM_BUCKETS);
#endif

#ifdef _CUTIL_H_
  CUDA_SAFE_CALL(cudaMemcpy(Cbuckets, buckets, sizeof(LinkedList*)*NUM_BUCKETS, cudaMemcpyHostToDevice));
#else
  cudaMemcpy(Cbuckets, buckets, sizeof(LinkedList*)*NUM_BUCKETS, cudaMemcpyHostToDevice);
#endif

  cutStopTimer(hTimer) ;
  fprintf(stderr, "alloc and copy bucket pointers (%f MB) time: %f ms\n", ((double)sizeof(LinkedList*)*NUM_BUCKETS)/(1024*1024), cutGetTimerValue(hTimer));

  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;
             
#ifdef _CUTIL_H_
  CUDA_SAFE_CALL(cudaMalloc((void**)&(Cbuckets), sizeof(LinkedList*)*NUM_BUCKETS));
#else
  cudaMalloc((void**)&(Cbuckets), sizeof(LinkedList*)*NUM_BUCKETS);
#endif

#ifdef _CUTIL_H_
  CUDA_SAFE_CALL(cudaMemcpy(Cbuckets, buckets, sizeof(LinkedList*)*NUM_BUCKETS, cudaMemcpyHostToDevice));
#else
  cudaMemcpy(Cbuckets, buckets, sizeof(LinkedList*)*NUM_BUCKETS, cudaMemcpyHostToDevice);
#endif

  cutStopTimer(hTimer) ;
  fprintf(stderr, "alloc and copy bucket pointers (%f MB) time: %f ms\n", ((double)sizeof(LinkedList*)*NUM_BUCKETS)/(1024*1024), cutGetTimerValue(hTimer));

  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;


  // Initialize the device memory
  
  int b=(NUM_BUCKETS/32)+1;
  init<<<b, 32>>>(Cbuckets);
  if ((rc = cudaGetLastError()) != cudaSuccess)
  {
    fprintf(stderr, "init kernel error %d\n", rc);
  }
  cutilDeviceSynchronize();
  if ((rc = cudaGetLastError()) != cudaSuccess)
  {
    fprintf(stderr, "init sync error %d\n", rc);
  }
  
  cutStopTimer(hTimer) ;
  fprintf(stderr, "init kernel time: %f ms\n", cutGetTimerValue(hTimer));

  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;
   
  // Allocate the pool of free nodes
  Node** pointers=(Node**)malloc(sizeof(Node*)*NUM_ITEMS);
  Node** Cpointers;
  for(i=0;i<NUM_ITEMS;i++){
#ifdef _CUTIL_H_
    CUDA_SAFE_CALL(cudaMalloc((void**)&pointers[i], sizeof(Node)));
#else
    cudaMalloc((void**)&pointers[i], sizeof(Node));
#endif
  }
   
  cutStopTimer(hTimer) ;
  fprintf(stderr, "alloc device free nodes in loop (%d calls to cudaMalloc) time: %f ms\n", NUM_ITEMS, cutGetTimerValue(hTimer));

  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;

#ifdef _CUTIL_H_
  CUDA_SAFE_CALL(cudaMalloc((void**)&Cpointers, sizeof(Node*)*NUM_ITEMS));
  CUDA_SAFE_CALL(cudaMemcpy(Cpointers, pointers, sizeof(Node*)*NUM_ITEMS, cudaMemcpyHostToDevice));
#else
  cudaMalloc((void**)&Cpointers, sizeof(Node*)*adds);
  cudaMemcpy(Cpointers, pointers, sizeof(Node*)*adds, cudaMemcpyHostToDevice);
#endif

  cutStopTimer(hTimer) ;
  fprintf(stderr, "alloc and copy device free node pointres (%f MB) time: %f ms\n", (double)sizeof(Node*)*NUM_ITEMS/(1024*1024), cutGetTimerValue(hTimer));



  if (cudaMalloc((void **)&d_profit, sizeof(unsigned int)) != cudaSuccess)
  {
    fprintf(stderr, "cudaMalloc d_profit failed\n");
    exit(1);
  }

  cutResetTimer(hTimer) ;
  cutStartTimer(hTimer) ;
  
  /* Run the kernel */
  dim3 dimGrid(blocks)      ; // blocks
  dim3 dimBlock(NUM_THREADS); // threads

  dp_knapsack_kernel<<<dimGrid, dimBlock>>>(NUM_KNAPSACK_ITEMS, CAPACITY, d_profit, devStates);
  if ((rc = cudaGetLastError()) != cudaSuccess)
  {
    fprintf(stderr, "knapsack kernel error %d\n", rc);
  }
  cutilDeviceSynchronize();
  if ((rc = cudaGetLastError()) != cudaSuccess)
  {
    fprintf(stderr, "knapsack sync error %d\n", rc);
  }
  cutStopTimer(hTimer) ;
  fprintf(stderr, "knapsack kernel time: %f ms\n", cutGetTimerValue(hTimer));
 
  cudaMemcpy(&profit, d_profit, sizeof(unsigned int), cudaMemcpyDeviceToHost);
  
  ttime=etime=otime=0; // FIXME TODO timings
  printf("%u %d %d %d %d %s %s", 
	 profit, 
         
         0, 0, // TODO instrumentation
         
         ttime, etime, flags, name);


  /* clean up */
  cudaFree(devStates);
  for (i = 0; i < NUM_BUCKETS; i++)
    cudaFree(buckets[i]);
  cudaFree(Cbuckets);
  for (i =0; i < NUM_ITEMS; i++)
    cudaFree(pointers[i]);
  cudaFree(Cpointers);
  cutilDeviceReset();
  free(KNAPSACK_ITEMS);
  exit(0);
  
}
